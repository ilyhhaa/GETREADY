// See https://aka.ms/new-console-template for more information
Console.WriteLine("Hello, World!");


/*

[88%]
В чём разница абстрактного класса и интерфейса?

Думайте об этом по-другому.
Абстрактный класс — это «заготовка» класса: реализовано большинство методов (включая внутренние), кроме нескольких.
Эти несколько нереализованных методов вполне могут быть внутренними методами класса, они лишь уточняют детали имплементации.
Абстрактный класс — средство для повторного использования кода, средство, чтобы указать,
какой метод обязан быть перекрыт для завершения написания класса.
Интерфейс же — это своего рода контракт: интерфейсы используются в определениях чтобы указать, что объект, который будет использован на
самом деле, должен реализовывать (для входных параметров) или будет гарантированно реализовывать (для выходных параметров) набор методов и (что намного важнее!)
иметь определённую семантику. Интерфейс вполне может быть и пустым, тем не менее, имплементировать интерфейс означает поддерживать данную семантику.
Абстрактные классы идеологически схожи с шаблонами C++: и те, и другие являются заготовками классов, но шаблону для получения класса нужно специфицировать шаблонные типы, 
а абстрактному классу — абстрактные методы.
Интерфейсы идеологически схожи с заголовочными файлами C++: они раскрывают методы и скрывают конкретную реализацию.
Вопрос о том, является ли интерфейс или абстрактный класс собственно классом — техническая подробность реализации, зависящая от конкретного языка программирования.


77% Что такое Inversion of control и dependency injection?

Инверсия управления (IoC) - это паттерн, который помогает уменьшить зависимости между объектами в приложении, делая его более развязанным и поддерживаемым. 
Давай рассмотрим это подробнее.
1.	Что такое Инверсия управления (IoC)?
o	IoC позволяет перенести контроль над созданием и взаимодействием объектов из кода приложения во внешний механизм.
o	Вместо того чтобы объекты создавали друг друга напрямую, они зависят от абстракций, которые предоставляются внешними компонентами (например, контейнерами IoC).
o	Это помогает уменьшить сильную связанность между классами и делает код более гибким.

2.	Принцип инверсии зависимостей (Dependency Inversion Principle, DIP)
o	DIP - это один из принципов SOLID, который лежит в основе IoC.
o	Он гласит, что высокоуровневые модули не должны зависеть от низкоуровневых модулей. Оба должны зависеть от абстракций.
o	Вместо того чтобы создавать объекты напрямую, мы внедряем зависимости через интерфейсы или абстрактные классы.

o	Представь, что у нас есть игрушечный магазин. У нас есть класс ToyStore, который отвечает за продажу игрушек.
o	Вместо того чтобы создавать объекты игрушек внутри ToyStore, мы будем передавать их через конструктор:

public class ToyStore
{
    private readonly IToy _toy;

    public ToyStore(IToy toy)
    {
        _toy = toy;
    }

    public void SellToy()
    {
        Console.WriteLine($"Продаем {_toy.Name}!");
    }
}


DI ВНЕДРЕНИЕ ЗАВИСИМОСТЕЙ 

Что такое внедрение зависимостей?

Внедрение зависимостей - это паттерн, который помогает нам создавать программные компоненты, которые не сильно связаны друг с другом.
Представь, что у нас есть магазин игрушек. Мы хотим продавать разные виды игрушек, такие как мячи, куклы и машинки.
Вместо того чтобы создавать каждую игрушку внутри магазина, мы будем передавать их в магазин извне.

Создадим интерфейс IToy, который определит общие методы для всех игрушек:

public interface IToy
{
    string Name { get; } // Имя игрушки
    void Play(); // Метод для игры с игрушкой
}

Теперь создадим две игрушки: мяч и куклу, реализующие интерфейс IToy:

public class Ball : IToy
{
    public string Name => "Красный мяч";

    public void Play()
    {
        Console.WriteLine($"Играем с {Name}!");
    }
}

public class Doll : IToy
{
    public string Name => "Кукла Анна";

    public void Play()
    {
        Console.WriteLine($"Играем с {Name}!");
    }
}

3.Теперь создадим класс ToyStore, который будет продавать игрушки:

public class ToyStore
{
    private readonly IToy _toy;

    public ToyStore(IToy toy)
    {
        _toy = toy;
    }

    public void SellToy()
    {
        Console.WriteLine($"Продаем {_toy.Name}!");
    }
}

4.Внедрим зависимость в магазин:


var ball = new Ball();
var doll = new Doll();

var toyStore = new ToyStore(ball);
toyStore.SellToy(); // Выведет: "Продаем Красный мяч!"

toyStore = new ToyStore(doll);
toyStore.SellToy(); // Выведет: "Продаем Кукла Анна!"

Теперь магазин не заботится о том, какие именно игрушки он продает.
Он просто получает их извне и продает.
Это делает нашу программу более гибкой и легко расширяемой.



77% Что такое middleware в ASP.NET core?


Middleware — это программные компоненты, которые выполняются при каждом запросе к приложению и обрабатываются в определенном порядке в виде конвейера.
Эти компоненты могут выполнять различные задачи, такие как аутентификация, логирование, обработка ошибок, управление сессиями, и многое другое.
Он позволяет добавлять и настраивать функциональность приложения в точках, через которые проходит HTTP-запрос или ответ.

Как он работает

Каждый его компонент имеет возможность обработать запрос перед тем, как он будет передан следующему компоненту в конвейере, а также может изменять 
ответ после выполнения последующих компонентов. Такая архитектура позволяет создавать легко расширяемые и модульные приложения.

Middleware конфигурируется в методе `Configure` класса `Startup`. Порядок, в котором компоненты middleware добавляются в конвейер с помощью метода 
`Use...`, определяет порядок их выполнения при обработке запроса и ответа.

Пример:

```csharp
public class MyMiddleware
{
    private readonly RequestDelegate _next;

    public MyMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        // До вызова следующего компонента в конвейере
        Console.WriteLine("Before");

        await _next(context); // Передача управления следующему middleware

        // После возвращения управления от следующих компонентов
        Console.WriteLine("After");
    }
}

// Регистрация middleware в Startup.cs
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    app.UseMiddleware<MyMiddleware>();
    // Другие компоненты middleware
}
```
Middleware часто используют для следующих задач:

Аутентификация и авторизация: проверка пользовательских данных и определение прав доступа.
Логирование: запись информации о запросах и ответах для последующего анализа.
Обработка ошибок: централизованная обработка исключений и формирование соответствующих ответов клиенту.
Управление сессиями и куками: поддержка пользовательских сессий и управление куками.
Статические файлы: обработка запросов к статическим файлам, таким как HTML, CSS, изображения.
Middleware обеспечивает гибкую и мощную систему для управления потоком HTTP-запросов и ответов, позволяя разработчикам легко добавлять
и настраивать необходимую функциональность в своих веб-приложениях.

Middleware в ASP.NET Core — это компоненты, которые работают с каждым запросом и ответом в приложении, формируя конвейер для обработки
HTTP-сообщений. Они позволяют добавлять нужную функциональность, например, для логирования, аутентификации или обработки ошибок, делая приложение
модульным и легко поддерживаемым.



77% ЛЯМБДА ВЫРАЖЕНИЯ

Лямбда-выражения — это сокращённый способ записи анонимных методов, то есть методов без имени.
Эти выражения особенно полезны для создания небольших функций, которые можно передавать в качестве аргументов или использовать в качестве типов делегатов. 
Они упрощают код и делают его более читаемым, особенно когда речь идёт о работе с коллекциями или асинхронном программировании.

Основной синтаксис лямбда-выражения выглядит так:

```csharp
параметры => выражение
```
Где `=>` называется лямбда оператором, который можно прочесть как "переходит к".

Пример без параметров:

```csharp
() => Console.WriteLine("Привет, мир!");
```
Пример с одним параметром:

```csharp
x => x * x; // Возвращает квадрат x
```
Пример с несколькими параметрами:

```csharp
(x, y) => x + y; // Складывает x и y
```
Зачем они нужны?

Лямбда-выражения особенно полезны в LINQ (Language Integrated Query), где они используются для создания кратких и выразительных запросов к данным.
Например, чтобы выбрать все положительные числа из списка, можно использовать лямбда-выражение следующим образом:

```csharp
List<int> числа = new List<int> { -1, 0, 1, 2, 3, 4, 5 };
var положительныеЧисла = числа.Where(x => x > 0).ToList();

foreach (var число in положительныеЧисла)
{
    Console.WriteLine(число);
}
```
Лямбда-выражения также могут быть использованы для создания делегатов в событийно-ориентированных 
или асинхронных программах, делая код более лаконичным и легко читаемым.

Лямбда-выражения предоставляют мощный и гибкий способ работы с функциями, позволяя писать компактный и выразительный код.
Они идеально подходят для выполнения операций с коллекциями, асинхронного
программирования и везде, где требуется краткость и выразительность.


77%

Когда инициируется сборка мусора???????
Сборка мусора (Garbage Collection, GC) автоматически управляет выделением и освобождением памяти в управляемом куче. Сборка мусора инициируется автоматически в следующих ситуациях:

1. Недостаток памяти: Если приложению требуется больше памяти для выделения объектов в управляемой куче и доступной памяти недостаточно
, CLR (Common Language Runtime) автоматически инициирует сборку мусора для освобождения памяти, занятой неиспользуемыми объектами.

2. Достигнут порог выделения памяти: .NET Framework использует алгоритм, который основывается на объеме выделенной памяти.
Для каждого поколения объектов (0, 1, и 2) определен пороговый объем выделенной памяти. 
Когда приложение выделяет память и этот порог достигается, 
происходит сборка мусора соответствующего поколения.

3. Вызов GC.Collect(): Разработчики могут явно запросить сборку мусора, вызвав метод `GC.Collect()`.
Однако использовать этот метод нужно осторожно, так как его неправильное использование может привести к снижению производительности приложения.
В большинстве случаев следует избегать явного вызова сборки мусора и полагаться на автоматическое управление памятью CLR.

4. Завершение работы приложения: При завершении работы приложения .NET Framework автоматически выполняет
сборку мусора для очистки всех управляемых объектов, даже если они еще доступны.

5. Низкий уровень памяти в системе: Если операционная система сообщает о низком уровне доступной памяти, 
CLR может инициировать сборку мусора в попытке освободить память для системы.

Сборка мусора проектировалась таким образом, чтобы минимизировать необходимость вмешательства программиста
в процесс управления памятью. Она позволяет автоматически решать большинство задач по освобождению памяти, 
что значительно упрощает разработку и повышает надежность программ на .NET.

77%

Что такое полиморфизм
Полиморфизм — это ключевой принцип ООП, который позволяет одному и тому же интерфейсу принимать множество различных форм.
В контексте программирования он обеспечивает возможность работать с объектами разных классов, как если бы они были объектами одного класса,
основываясь на общности их поведения. Это достигается за счет использования общих интерфейсов или классов наследования.

Виды:

полиморфизм может проявляться в двух основных формах:1. Статический (или компиляционный) полиморфизм: 
Реализуется с помощью перегрузки методов (методы в одном классе имеют одинаковое имя, но различаются количеством или типом параметров) и перегрузки операторов.
Статический полиморфизм определяется во время компиляции.

   ```csharp
   class MathOperations
   {
       public int Multiply(int a, int b)
       {
           return a * b;
       }

       public int Multiply(int a, int b, int c)
       {
           return a * b * c;
       }
   }
   ```
2. Динамический (или времени выполнения) полиморфизм:
Реализуется с помощью переопределения методов (когда методы в дочернем классе переопределяют методы родительского класса).
Динамический полиморфизм использует механизм виртуальных методов и их переопределения (override) 
и определяется во время выполнения программы.

   ```csharp
   class Animal
   {
       public virtual void MakeSound()
       {
           Console.WriteLine("Some sound");
       }
   }

   class Dog : Animal
   {
       public override void MakeSound()
       {
           Console.WriteLine("Woof");
       }
   }
   ```
В этом примере метод `MakeSound` в классе `Animal` переопределяется в классе `Dog` для предоставления реализации, специфичной для собак.
При вызове `MakeSound` на экземпляре `Dog`, будет использоваться переопределенная версия метода, что является демонстрацией динамического полиморфизма.

Зачем он нужен?

Полиморфизм упрощает добавление новых классов и функциональностей в программы без изменения существующего кода. Он способствует уменьшению связанности компонентов системы,
упрощению ее расширения и облегчению поддержки. Полиморфизм также играет важную роль в реализации принципов SOLID, в частности, в обеспечении гибкости и масштабируемости 
программного обеспечения.


77%

Ключевые слова `async` и `await` используются для упрощения асинхронного программирования, делая асинхронный код более читаемым и понятным, похожим на синхронный.
Эти ключевые слова являются частью асинхронной модели программирования, которая позволяет выполнение длительных операций, таких как доступ к сети или операции ввода-вывода,
без блокировки основного потока приложения. Это важно для разработки отзывчивых приложений, особенно в GUI или серверных приложениях, где производительность и способность 
отвечать на пользовательский ввод критичны.

Принцип работы

async: Это модификатор, который применяется к методу, указывая, что метод является асинхронным и внутри него можно использовать `await`.
Методы с модификатором `async` всегда возвращают `void`, `Task` или `Task<T>`, где `T` — тип возвращаемого значения. Методы, возвращающие `Task` или `Task<T>`, 
могут быть ожидаемыми с помощью `await`, что означает, что их выполнение можно приостановить, ожидая завершения асинхронной операции, не блокируя при этом поток.
await: Ключевое слово `await` используется для приостановки выполнения метода до тех пор, пока асинхронная задача, которую оно сопровождает, не будет завершена. 
Важно отметить, что `await` не блокирует поток, на котором он был вызван, позволяя другим 
операциям выполняться в этом потоке. После завершения асинхронной задачи выполнение метода 
продолжается с точки, где оно было приостановлено.
```csharp
public class Example
{
    // Определение асинхронного метода
    public async Task<int> GetCalculationAsync()
    {
        Console.WriteLine("Starting calculation...");
        
        // Асинхронно ожидаем завершения длительной операции
        var result = await Task.Run(() =>
        {
            Thread.Sleep(5000); // Имитация длительной операции
            return 42;
        });

        Console.WriteLine("Calculation completed.");
        return result;
    }

    public async Task ExecuteAsync()
    {
        int result = await GetCalculationAsync();
        Console.WriteLine($"Result: {result}");
    }
}

// В точке входа приложения вызываем асинхронный метод
static async Task Main(string[] args)
{
    Example example = new Example();
    await example.ExecuteAsync();
}
```
Разработка GUI: Использование `async` и `await` позволяет UI оставаться отзывчивым, пока выполняются длительные операции,
такие как загрузка данных или обращение к файловой системе.
Web-разработка: В веб-приложениях асинхронное программирование используется для эффективной обработки веб-запросов,
что особенно важно при обращении к внешним ресурсам, таким как базы данных или веб-сервисы.
`async` и `await` облегчают написание асинхронного кода, позволяя писать код, который легко читается как последовательный, 
но функционирует асинхронно для повышения отзывчивости и производительности приложений.


77%
Какие знаешь делегаты

Делегаты представляют собой ссылки на методы и используются для выполнения кода в ответ на события или для вызова методов в параметризированном виде. 
Делегаты позволяют программам определять, какой метод будет вызываться в ответ на определенное действие, 
что делает код более гибким и легко масштабируемым.

Встроенные типы

Предоставляет несколько встроенных типов делегатов, которые можно использовать для создания делегатов без необходимости определять пользовательский делегат:

1. Action: Это делегат, который может указывать на метод, который не принимает параметров и не возвращает значение. 
`Action` также может быть обобщённым, принимая от 0 до 16 параметров:

   ```csharp
   Action<string> printAction = s => Console.WriteLine(s);
   printAction("Hello, Action!");
   ```
2. Func: Этот делегат указывает на метод, который возвращает значение. `Func` делегаты могут принимать от 0 до 16 параметров, и последний тип в обобщении 
`Func` — это возвращаемый тип:

   ```csharp
   Func<int, int, int> sumFunc = (x, y) => x + y;
   int result = sumFunc(5, 3);  // Вывод: 8
   ```
3. Predicate: Это специализация делегата `Func` для ситуаций, когда нужно возвращать `bool`. Он всегда принимает один параметр и возвращает `bool`:

   ```csharp
   Predicate<int> isPositive = x => x > 0;
   bool positive = isPositive(-1);  // Вывод: false
   ```
Вы можете определить собственные типы делегатов, если встроенные не соответствуют вашим требованиям. 
Для этого используется ключевое слово `delegate`:

```csharp
public delegate void MyCustomDelegate(string message);

public class Program
{
    public static void ShowMessage(string message)
    {
        Console.WriteLine(message);
    }

    static void Main(string[] args)
    {
        MyCustomDelegate del = new MyCustomDelegate(ShowMessage);
        del("Hello, Custom Delegate!");
    }
}
```
Использование делегатов

Делегаты широко используются для реализации обратных вызовов и событийной модели. Они также часто применяются в 
LINQ для создания динамических запросов и в асинхронном программировании.

Делегаты обеспечивают высокий уровень абстракции и позволяют программам быть более модульными и легко адаптируемыми к
изменениям, поскольку компоненты программы могут взаимодействовать друг с другом, не зная точной реализации вызываемого кода.

Делегаты — это мощный механизм для передачи методов как параметров. Они предоставляют способ создать переменную, которая
может хранить ссылку на методы, что позволяет вызывать эти методы и передавать их другим методам или классам для последующего использования.
Это делает код более гибким и модульным.



88%
LINQ (Language Integrated Query) — это мощная функциональность языка C#, которая позволяет интегрированно и унифицированно выполнять запросы
к различным источникам данных непосредственно из кода. Включает в себя набор методов расширения и синтаксис, который позволяет выполнять 
запросы к коллекциям объектов, базам данных, XML документам и любым другим формам данных, которые могут быть представлены как коллекции.

Основные особенности:

1. Единообразие: Gозволяет использовать один и тот же синтаксический подход при работе с различными источниками данных, будь то коллекции 
объектов в памяти (LINQ to Objects), базы данных (LINQ to SQL, Entity Framework)
, XML документы (LINQ to XML) или даже удалённые данные (LINQ to Entities).

2. Интеграция с языком: Nесно интегрирован с C#, что позволяет использовать все возможности языка, 
такие как интеллисенс, строгая типизация и компиляция запросов, что повышает безопасность и производительность.

3. Читабельность и краткость: Запросы LINQ часто гораздо более читабельны и кратки,
чем эквивалентные императивные подходы к обработке данных.
Это упрощает написание, чтение и поддержку кода.

Примеры использования:

To Objects

```csharp
List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };
var evenNumbers = from num in numbers
                  where num % 2 == 0
                  select num;

foreach (var num in evenNumbers)
{
    Console.WriteLine(num); // Выводит 2, 4, 6
}
```
To SQL

```csharp
using (DataContext db = new DataContext())
{
    var query = from customer in db.Customers
                where customer.City == "London"
                select customer;

    foreach (var customer in query)
    {
        Console.WriteLine(customer.Name);
    }
}
```
To XML

```csharp
XElement root = XElement.Load("customers.xml");
var customerNames = from customer in root.Elements("customer")
                     where (int)customer.Element("age") > 30
                     select customer.Element("name").Value;

foreach (var name in customerNames)
{
    Console.WriteLine(name);
}
```
Применение:

Обработка данных: Идеально подходит для фильтрации, сортировки и агрегации больших объёмов данных.
Подключение к базам данных: Может использоваться для создания запросов к базам данных, что упрощает 
код и делает его более безопасным благодаря строгой типизации.
Работа с XML: LINQ to XML предоставляет удобные инструменты для работы с XML,
позволяя легко извлекать и изменять данные.
LINQ — это мощный инструмент для работы с данными, который позволяет писать запросы прямо в коде,
обеспечивая единообразие, безопасность и высокую читабельность кода.


50%

В чём разница между string и StringBuilder
`string` и `StringBuilder` используются для работы с текстом, но они значительно
отличаются по своим характеристикам и предназначению:

1. Иммутабельность (Неизменяемость)

string: Класс `string` представляет неизменяемые строки. Это значит, что после создания экземпляра строки его содержимое изменить нельзя. 
Каждый раз, когда вы выполняете операцию, которая кажется изменяющей строку (например, конкатенация), на самом деле создается новый экземпляр строки. 
Это может привести к значительным накладным расходам памяти при частой модификации строк.
  ```csharp
  string s = "Hello";
  s += ", World!"; // Создается новая строка "Hello, World!" и s теперь ссылается на неё
  ```
StringBuilder: В отличие от строк, `StringBuilder` предназначен для создания и модификации строки без необходимости каждый раз создавать новый экземпляр.
`StringBuilder` поддерживает изменяемый буфер для хранения символов, что позволяет 
выполнять операции, такие как добавление, удаление и вставка символов, с меньшими накладными 
расходами по памяти и производительности.

  ```csharp
  StringBuilder sb = new StringBuilder("Hello");
  sb.Append(", World!"); // Просто добавляет ", World!" к существующему буферу
  ```
2. Производительность

string: Из-за неизменяемости строки не подходят для сценариев, где необходимо часто изменять или добавлять содержимое,
особенно при больших объемах данных. Каждая операция модификации создает новый экземпляр строки, что приводит к временным 
затратам и использованию большего количества памяти.
StringBuilder: Оптимизирован для частых изменений и может значительно улучшить производительность в приложениях, где требуется 
выполнение множества операций по изменению строки. `StringBuilder` не создает новый экземпляр строки при каждом изменении
, а изменяет существующий буфер.

3. Когда использовать

string: Идеально подходит для работы со строками, которые не требуют частых изменений после их создания. 
Простота использования и поддержка литерального синтаксиса делают их удобным выбором для хранения текста, который не изменяется.
StringBuilder: Лучше использовать в сценариях, где предполагается многократное изменение содержимого строки,
например, в циклах, где к строке добавляются или из неё удаляются символы.

Пример:

```csharp
// Использование string в ситуации, когда StringBuilder был бы предпочтительнее
string result = "";
for (int i = 0; i < 10000; i++) {
    result += i;  // Очень неэффективно из-за создания новой строки на каждой итерации
}

// Использование StringBuilder
StringBuilder sbResult = new StringBuilder();
for (int i = 0; i < 10000; i++) {
    sbResult.Append(i);  // Эффективно, изменяет существующий буфер
}
```
`string` - это для неизменяемого текста, используется когда изменения не требуются. 
`StringBuilder` - это для изменяемого текста, используется когда нужно часто изменять строку,
что делает его более эффективным в таких сценариях.


55%

Что такое EF
Entity Framework (EF) — это объектно-реляционный маппер (ORM), разработанный компанией Microsoft, позволяющий работать с данными на высоком уровне абстракции,
оперируя объектами и классами вместо прямых запросов к базе данных. Предоставляет мощные возможности для моделирования, запросов, сохранения и обработки данных
в различных базах данных, таких как SQL Server, MySQL, SQLite и других.

Основные компоненты и возможности:

1. DbContext: Это основной класс в EF, который управляет взаимодействием с базой данных. 
Он предоставляет доступ к функциональности, такой как выполнение запросов, сохранение данных и настройка моделей.

2. DbSet: Это коллекции объектов определенного класса, которые представляют собой таблицы в базе данных.
Классы, которые представляют данные в таблицах, обычно называются сущностями.

3. LINQ to Entities: EF позволяет использовать LINQ (Language Integrated Query) для написания запросов к базе данных, которые затем транслируются в SQL-запросы.
Это позволяет разработчикам писать запросы к данным в объектно-ориентированном стиле на C#.

4. Миграции: EF поддерживает механизм миграций для управления изменениями в структуре базы данных по мере развития приложения.
Миграции позволяют автоматически обновлять схему базы данных в соответствии с изменениями в моделях данных.

5. Конвенции и настройки: Entity Framework использует набор конвенций для автоматического маппинга классов на таблицы и их свойств на столбцы. 
Разработчики могут переопределить и дополнить эти конвенции с помощью аннотаций данных или Fluent API.

Версии:

Entity Framework 6 (EF6): Последняя версия для .NET Framework. EF6 продолжает поддерживаться и развиваться, включая новые функции и исправления ошибок.
Entity Framework Core (EF Core): Современная, легковесная, расширяемая и кросс-платформенная версия Entity Framework, разработанная для .NET Core. 
EF Core предназначен для использования в модернизированных и масштабируемых приложениях и поддерживает широкий спектр баз данных.

```csharp
using (var context = new BloggingContext())
{
    var blog = new Blog { Url = "http://blogs.msdn.com/adonet" };
    context.Blogs.Add(blog);
    context.SaveChanges();

    var blogs = context.Blogs
                       .Where(b => b.Url.Contains("msdn"))
                       .ToList();
    foreach (var b in blogs)
    {
        Console.WriteLine(b.Url);
    }
}
```
В этом примере создается новый объект `Blog`, добавляется в контекст и сохраняется в базе данных.
Затем выполняется запрос для извлечения блогов с определенным URL.

Entity Framework значительно упрощает работу с реляционными базами данных, 
позволяя разработчикам сосредоточиться на бизнес-логике, вместо деталей реализации доступа к данным.
Он предлагает мощные инструменты для абстракции доступа к данным, что делает код чище, проще для понимания и поддержки.



Было принято судьбаносное решение 
*/